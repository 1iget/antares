menuconfig CONTRIB_LWIP
bool "Lightweight TCP/IP stack"
depends on SHOW_BROKEN

if CONTRIB_LWIP



config LWIP_INCLUDE_USER
bool "Include lwipextraopts.h"
help
	This file is designed for stuff you can't config
	with kconfig.

menu "Platform specific locking"

config LWIP_SYS_LIGHTWEIGHT_PROT
bool "Lightweight inter-task protection"
help
	Set if you want inter-task protection for certain
 	critical regions during buffer allocation, deallocation and memory
 	allocation and deallocation.

config LWIP_NO_SYS
bool "Provide minimal functionality"

config LWIP_NO_SYS_NO_TIMERS
bool "Drop support for sys_timeout"
depends on LWIP_NO_SYS

endmenu

menu "Memory options"

config LWIP_MEM_LIBC_MALLOC
bool "Use malloc from libc"
help
	Use malloc/free/realloc provided by your C-library
 	instead of the lwip internal allocator. Can save code size if you
 	already use it.

config LIBC_MEMP_MEM_MALLOC
bool "Use mem_malloc/mem_free instead of the lwip pool allocator"
help
	Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
	speed and usage from interrupts!

config LWIP_MEM_ALIGNMENT
int "Memory alignment of the target CPU"
default 4 if ARCH_ARM
default 2 if ARCH_AVR
default 2 if ARCH_MSP430

config LWIP_MEM_SIZE
int "Heap memory size"
default 1600
help
	MEM_SIZE: the size of the heap memory. If the application will send
 	a lot of data that needs to be copied, this should be set high.


config LWIP_MEMP_SEPARATE_POOLS
bool "Place each array in a separate pool"
    help
    If set each pool is placed in its own array.
    This can be used to individually change the location of each pool.
    Default is one big array for all pools


choice 

prompt "Memp overflow protection"

config LWIP_MEMP_OVERFLOW_CHECK_0
bool "No checking"

config LWIP_MEMP_OVERFLOW_CHECK_1
bool "Check each element when it is freed"

config LWIP_MEMP_OVERFLOW_CHECK_2
bool "Checks everything on memp_malloc()/memp_free()"

endchoice

config LWIP_MEMP_SANITY_CHECK
bool "Run a sanity check after memp_free()"

config LWIP_MEM_USE_POOLS
bool "Use pools"
help
	Use an alternative to malloc() by allocating from a set
 	of memory pools of various sizes. When mem_malloc is called, an element of
 	the smallest pool that can provide the length needed is returned.
 	To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled.

config LWIP_MEM_USE_POOLS_TRY_BIGGER_POOL
bool "Try bigger pool"
help
	if one malloc-pool is empty, try the next bigger pool 
	WARNING: THIS MIGHT WASTE MEMORY but it can make a system more
 	reliable.

config LWIP_MEMP_USE_CUSTOM_POOLS
bool "Use custom pools"
help     
	 whether to include a user file lwippools.h
 	 that defines additional pools beyond the "standard" ones required
 	 by lwIP. If you set this to 1, you must have lwippools.h in your 
 	 inlude path somewhere. 

config LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
bool "Allow memfree from other contexts"
help
	Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from
 	interrupt context (or another context that doesn't allow waiting for a
 	semaphore).
 	If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT,
 	while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs
 	with each loop so that mem_free can run.
	ATTENTION: As you can see from the above description, this leads to dis-/
 	enabling interrupts often, which can be slow! Also, on low memory, mem_malloc
 	can need longer. 
	If you don't want that, at least for NO_SYS=0, you can still use the following
 	functions to enqueue a deallocation call which then runs in the tcpip_thread
 	context:
 	- pbuf_free_callback(p);
 	- mem_free_callback(m);
endmenu 


menu "Internal Memory Pool Sizes"

config LWIP_MEMP_NUM_PBUF
int "Number of memp struct pbufs"
default 16
help
	the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).
 	If the application sends a lot of data out of ROM (or other static memory),
 	this should be set high.

config LWIP_MEMP_NUM_RAW_PCB
int "Number of raw conection PCBs"
default 4
depends on LWIP_RAW	

config LWIP_MEMP_NUM_UDP_PCB
int "UDP Protocol control blocks"
default 4
depends on LWIP_UDP

config LWIP_MEMP_NUM_TCP_PCB
int "Maximum simultaneous TCP/IP connections"
depends on LWIP_TCP
default 5

config LWIP_MEMP_NUM_TCP_PCB_LISTEN
int "Maximum simultaneous listening TCP/IP connections"
depends on LWIP_TCP
default 5

config LWIP_MEMP_NUM_TCP_SEG
int "Number of simultaneously queued TCP segments"
depends on LWIP_TCP
default 16
endmenu

config LWIP_MEMP_NUM_REASSDATA
int "Number of IP packets simultaneously queued for reassembly"
default 16
help
	(whole packets, not fragments!)


config LWIP_MEMP_NUM_FRAG_PBUF
int "Number of IP fragments simultaneously sent"
depends on !LWIP_FRAG_USES_STATIC_BUF && !LWIP_TX_SINGLE_PBUF
default 15
help
	the number of IP fragments simultaneously sent
 	(fragments, not whole packets!).
 	This is only used with IP_FRAG_USES_STATIC_BUF==0 and
 	LWIP_NETIF_TX_SINGLE_PBUF==0 and only has to be > 1 with DMA-enabled MACs
 	where the packet is not yet sent when netif->output returns. 

config LWIP_NUM_ARP_QUEUE
int "ARP queue size"
default 15
	help
	The number of multicast groups whose network interfaces
 	can be members et the same time (one per netif - allsystems group -, plus one
 	per netif membership).
 	(requires the LWIP_IGMP option

endif
