# AUTOGENERATED
# DO NOT SUBMIT PATCHES AGAINST THIS FILE
menu "Platform specific locking"

config LWIP_SYS_LIGHTWEIGHT_PROT
bool "SYS_LIGHTWEIGHT_PROT"
default n 
help
	/**
	* SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
	* critical regions during buffer allocation, deallocation and memory
	* allocation and deallocation.
	*/

config LWIP_NO_SYS
bool "NO_SYS"
default n 
help
	/**
	* NO_SYS==1: Provides VERY minimal functionality. Otherwise,
	* use lwIP facilities.
	*/

config LWIP_NO_SYS_NO_TIMERS
bool "NO_SYS_NO_TIMERS"
default n 
help
	/**
	* NO_SYS_NO_TIMERS==1: Drop support for sys_timeout when NO_SYS==1
	* Mainly for compatibility to old versions.
	*/


 endmenu 


menu "Memory options"

config LWIP_MEM_LIBC_MALLOC
bool "MEM_LIBC_MALLOC"
default n 
help
	/**
	* MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library
	* instead of the lwip internal allocator. Can save code size if you
	* already use it.
	*/

config LWIP_MEMP_MEM_MALLOC
bool "MEMP_MEM_MALLOC"
default n 
help
	/**
	* MEMP_MEM_MALLOC==1: Use mem_malloc/mem_free instead of the lwip pool allocator.
	* Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
	* speed and usage from interrupts!
	*/

config LWIP_MEM_ALIGNMENT
int "MEM_ALIGNMENT"
default 1
help
	/**
	* MEM_ALIGNMENT: should be set to the alignment of the CPU
	*    4 byte alignment -> #define MEM_ALIGNMENT 4
	*    2 byte alignment -> #define MEM_ALIGNMENT 2
	*/

config LWIP_MEMP_SEPARATE_POOLS
bool "MEMP_SEPARATE_POOLS"
default n 
help
	/**
	* MEMP_SEPARATE_POOLS: if defined to 1, each pool is placed in its own array.
	* This can be used to individually change the location of each pool.
	* Default is one big array for all pools
	*/

config LWIP_MEMP_OVERFLOW_CHECK
bool "MEMP_OVERFLOW_CHECK"
default n 
help
	/**
	* MEMP_OVERFLOW_CHECK: memp overflow protection reserves a configurable
	* amount of bytes before and after each memp element in every pool and fills
	* it with a prominent default value.
	*    MEMP_OVERFLOW_CHECK == 0 no checking
	*    MEMP_OVERFLOW_CHECK == 1 checks each element when it is freed
	*    MEMP_OVERFLOW_CHECK >= 2 checks each element in every pool every time
	*      memp_malloc() or memp_free() is called (useful but slow!)
	*/

config LWIP_MEMP_SANITY_CHECK
bool "MEMP_SANITY_CHECK"
default n 
help
	/**
	* MEMP_SANITY_CHECK==1: run a sanity check after each memp_free() to make
	* sure that there are no cycles in the linked lists.
	*/

config LWIP_MEM_USE_POOLS
bool "MEM_USE_POOLS"
default n 
help
	/**
	* MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set
	* of memory pools of various sizes. When mem_malloc is called, an element of
	* the smallest pool that can provide the length needed is returned.
	* To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled.
	*/

config LWIP_MEM_USE_POOLS_TRY_BIGGER_POOL
bool "MEM_USE_POOLS_TRY_BIGGER_POOL"
default n 
help
	/**
	* MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next
	* bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more
	* reliable. */

config LWIP_MEMP_USE_CUSTOM_POOLS
bool "MEMP_USE_CUSTOM_POOLS"
default n 
help
	/**
	* MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h
	* that defines additional pools beyond the "standard" ones required
	* by lwIP. If you set this to 1, you must have lwippools.h in your
	* inlude path somewhere.
	*/

config LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
bool "LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT"
default n 
help
	/**
	* Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from
	* interrupt context (or another context that doesn't allow waiting for a
	* semaphore).
	* If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT,
	* while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs
	* with each loop so that mem_free can run.
	*
	* ATTENTION: As you can see from the above description, this leads to dis-/
	* enabling interrupts often, which can be slow! Also, on low memory, mem_malloc
	* can need longer.
	*
	* If you don't want that, at least for NO_SYS=0, you can still use the following
	* functions to enqueue a deallocation call which then runs in the tcpip_thread
	* context:
	* - pbuf_free_callback(p);
	* - mem_free_callback(m);
	*/


 endmenu 


menu "Internal Memory Pool Sizes"

config LWIP_MEMP_NUM_NETDB
bool "MEMP_NUM_NETDB"
default y 
help
	/**
	* MEMP_NUM_NETDB: the number of concurrently running lwip_addrinfo() calls
	* (before freeing the corresponding memory using lwip_freeaddrinfo()).
	*/

config LWIP_MEMP_NUM_LOCALHOSTLIST
bool "MEMP_NUM_LOCALHOSTLIST"
default y 
help
	/**
	* MEMP_NUM_LOCALHOSTLIST: the number of host entries in the local host list
	* if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
	*/

config LWIP_MEMP_NUM_PPPOE_INTERFACES
bool "MEMP_NUM_PPPOE_INTERFACES"
default y 
help
	/**
	* MEMP_NUM_PPPOE_INTERFACES: the number of concurrently active PPPoE
	* interfaces (only used with PPPOE_SUPPORT==1)
	*/


 endmenu 


menu "ARP options"

config LWIP_ARP
bool "LWIP_ARP"
default y 
help
	/**
	* LWIP_ARP==1: Enable ARP functionality.
	*/

config LWIP_ARP_QUEUEING
bool "ARP_QUEUEING"
default n 
help
	/**
	* ARP_QUEUEING==1: Multiple outgoing packets are queued during hardware address
	* resolution. By default, only the most recent packet is queued per IP address.
	* This is sufficient for most protocols and mainly reduces TCP connection
	* startup time. Set this to 1 if you know your application sends more than one
	* packet in a row to an IP address that is not in the ARP cache.
	*/

config LWIP_ETHARP_TRUST_IP_MAC
bool "ETHARP_TRUST_IP_MAC"
default n 
help
	/**
	* ETHARP_TRUST_IP_MAC==1: Incoming IP packets cause the ARP table to be
	* updated with the source MAC and IP addresses supplied in the packet.
	* You may want to disable this if you do not trust LAN peers to have the
	* correct addresses, or as a limited approach to attempt to handle
	* spoofing. If disabled, lwIP will need to make a new ARP request if
	* the peer is not already in the ARP table, adding a little latency.
	* The peer *is* in the ARP table if it requested our address before.
	* Also notice that this slows down input processing of every IP packet!
	*/

config LWIP_ETHARP_SUPPORT_VLAN
bool "ETHARP_SUPPORT_VLAN"
default n 
help
	/**
	* ETHARP_SUPPORT_VLAN==1: support receiving ethernet packets with VLAN header.
	* Additionally, you can define ETHARP_VLAN_CHECK to an u16_t VLAN ID to check.
	* If ETHARP_VLAN_CHECK is defined, only VLAN-traffic for this VLAN is accepted.
	* If ETHARP_VLAN_CHECK is not defined, all traffic is accepted.
	*/

config LWIP_ETH_PAD_SIZE
bool "ETH_PAD_SIZE"
default n 
help
	/** ETH_PAD_SIZE: number of bytes added before the ethernet header to ensure
	* alignment of payload after that header. Since the header is 14 bytes long,
	* without this padding e.g. addresses in the IP header will not be aligned
	* on a 32-bit boundary, so setting this to 2 can speed up 32-bit-platforms.
	*/

config LWIP_ETHARP_SUPPORT_STATIC_ENTRIES
bool "ETHARP_SUPPORT_STATIC_ENTRIES"
default n 
help
	/** ETHARP_SUPPORT_STATIC_ENTRIES==1: enable code to support static ARP table
	* entries (using etharp_add_static_entry/etharp_remove_static_entry).
	*/


 endmenu 


menu "IP options"

config LWIP_IP_FORWARD
bool "IP_FORWARD"
default n 
help
	/**
	* IP_FORWARD==1: Enables the ability to forward IP packets across network
	* interfaces. If you are going to run lwIP on a device with only one network
	* interface, define this to 0.
	*/

config LWIP_IP_OPTIONS_ALLOWED
bool "IP_OPTIONS_ALLOWED"
default y 
help
	/**
	* IP_OPTIONS_ALLOWED: Defines the behavior for IP options.
	*      IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped.
	*      IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed).
	*/

config LWIP_IP_REASSEMBLY
bool "IP_REASSEMBLY"
default y 
help
	/**
	* IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets. Note that
	* this option does not affect outgoing packet sizes, which can be controlled
	* via IP_FRAG.
	*/

config LWIP_IP_FRAG
bool "IP_FRAG"
default y 
help
	/**
	* IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
	* that this option does not affect incoming packet sizes, which can be
	* controlled via IP_REASSEMBLY.
	*/

config LWIP_IP_FRAG_USES_STATIC_BUF
bool "IP_FRAG_USES_STATIC_BUF"
default n 
help
	/**
	* IP_FRAG_USES_STATIC_BUF==1: Use a static MTU-sized buffer for IP
	* fragmentation. Otherwise pbufs are allocated and reference the original
	* packet data to be fragmented (or with LWIP_NETIF_TX_SINGLE_PBUF==1,
	* new PBUF_RAM pbufs are used for fragments).
	* ATTENTION: IP_FRAG_USES_STATIC_BUF==1 may not be used for DMA-enabled MACs!
	*/

config LWIP_IP_SOF_BROADCAST
bool "IP_SOF_BROADCAST"
default n 
help
	/**
	* IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast
	* filter per pcb on udp and raw send operations. To enable broadcast filter
	* on recv operations, you also have to set IP_SOF_BROADCAST_RECV=1.
	*/

config LWIP_IP_SOF_BROADCAST_RECV
bool "IP_SOF_BROADCAST_RECV"
default n 
help
	/**
	* IP_SOF_BROADCAST_RECV (requires IP_SOF_BROADCAST=1) enable the broadcast
	* filter on recv operations.
	*/


 endmenu 


menu "ICMP options"

config LWIP_ICMP
bool "LWIP_ICMP"
default y 
help
	/**
	* LWIP_ICMP==1: Enable ICMP module inside the IP stack.
	* Be careful, disable that make your product non-compliant to RFC1122
	*/

config LWIP_BROADCAST_PING
bool "LWIP_BROADCAST_PING"
default n 
help
	/**
	* LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only)
	*/

config LWIP_MULTICAST_PING
bool "LWIP_MULTICAST_PING"
default n 
help
	/**
	* LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only)
	*/


 endmenu 


menu "RAW options"

config LWIP_RAW
bool "LWIP_RAW"
default y 
help
	/**
	* LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
	*/


 endmenu 


menu "DHCP options"

config LWIP_DHCP
bool "LWIP_DHCP"
default n 
help
	/**
	* LWIP_DHCP==1: Enable DHCP module.
	*/


 endmenu 


menu "AUTOIP options"

config LWIP_AUTOIP
bool "LWIP_AUTOIP"
default n 
help
	/**
	* LWIP_AUTOIP==1: Enable AUTOIP module.
	*/

config LWIP_DHCP_AUTOIP_COOP
bool "LWIP_DHCP_AUTOIP_COOP"
default n 
help
	/**
	* LWIP_DHCP_AUTOIP_COOP==1: Allow DHCP and AUTOIP to be both enabled on
	* the same interface at the same time.
	*/


 endmenu 


menu "SNMP options"

config LWIP_SNMP
bool "LWIP_SNMP"
default n 
help
	/**
	* LWIP_SNMP==1: Turn on SNMP module. UDP must be available for SNMP
	* transport.
	*/

config LWIP_SNMP_CONCURRENT_REQUESTS
bool "SNMP_CONCURRENT_REQUESTS"
default y 
help
	/**
	* SNMP_CONCURRENT_REQUESTS: Number of concurrent requests the module will
	* allow. At least one request buffer is required.
	* Does not have to be changed unless external MIBs answer request asynchronously
	*/

config LWIP_SNMP_TRAP_DESTINATIONS
bool "SNMP_TRAP_DESTINATIONS"
default y 
help
	/**
	* SNMP_TRAP_DESTINATIONS: Number of trap destinations. At least one trap
	* destination is required
	*/

config LWIP_SNMP_PRIVATE_MIB
bool "SNMP_PRIVATE_MIB"
default n 
help
	/**
	* SNMP_PRIVATE_MIB:
	* When using a private MIB, you have to create a file 'private_mib.h' that contains
	* a 'struct mib_array_node mib_private' which contains your MIB.
	*/

config LWIP_SNMP_SAFE_REQUESTS
bool "SNMP_SAFE_REQUESTS"
default y 
help
	/**
	* Only allow SNMP write actions that are 'safe' (e.g. disabeling netifs is not
	* a safe action and disabled when SNMP_SAFE_REQUESTS = 1).
	* Unsafe requests are disabled by default!
	*/


 endmenu 


menu "IGMP options"

config LWIP_IGMP
bool "LWIP_IGMP"
default n 
help
	/**
	* LWIP_IGMP==1: Turn on IGMP module.
	*/


 endmenu 


menu "DNS options"

config LWIP_DNS
bool "LWIP_DNS"
default n 
help
	/**
	* LWIP_DNS==1: Turn on DNS module. UDP must be available for DNS
	* transport.
	*/

config LWIP_DNS_DOES_NAME_CHECK
bool "DNS_DOES_NAME_CHECK"
default y 
help
	/** DNS do a name checking between the query and the response. */

config LWIP_DNS_LOCAL_HOSTLIST
bool "DNS_LOCAL_HOSTLIST"
default n 
help
	/** DNS_LOCAL_HOSTLIST: Implements a local host-to-address list. If enabled,
	*  you have to define
	*    #define DNS_LOCAL_HOSTLIST_INIT {{"host1", 0x123}, {"host2", 0x234}}
	*  (an array of structs name/address, where address is an u32_t in network
	*  byte order).
	*
	*  Instead, you can also use an external function:
	*  #define DNS_LOOKUP_LOCAL_EXTERN(x) extern u32_t my_lookup_function(const char *name)
	*  that returns the IP address or INADDR_NONE if not found.
	*/

config LWIP_DNS_LOCAL_HOSTLIST_IS_DYNAMIC
bool "DNS_LOCAL_HOSTLIST_IS_DYNAMIC"
default n 
help
	/** If this is turned on, the local host-list can be dynamically changed
	*  at runtime. */


 endmenu 


menu "UDP options"

config LWIP_UDP
bool "LWIP_UDP"
default y 
help
	/**
	* LWIP_UDP==1: Turn on UDP.
	*/

config LWIP_UDPLITE
bool "LWIP_UDPLITE"
default n 
help
	/**
	* LWIP_UDPLITE==1: Turn on UDP-Lite. (Requires LWIP_UDP)
	*/

config LWIP_NETBUF_RECVINFO
bool "LWIP_NETBUF_RECVINFO"
default n 
help
	/**
	* LWIP_NETBUF_RECVINFO==1: append destination addr and port to every netbuf.
	*/


 endmenu 


menu "TCP options"

config LWIP_TCP
bool "LWIP_TCP"
default y 
help
	/**
	* LWIP_TCP==1: Turn on TCP.
	*/

config LWIP_TCP_CALCULATE_EFF_SEND_MSS
bool "TCP_CALCULATE_EFF_SEND_MSS"
default y 
help
	/**
	* TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
	* sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which
	* reflects the available reassembly buffer size at the remote host) and the
	* largest size permitted by the IP layer" (RFC 1122)
	* Setting this to 1 enables code that checks TCP_MSS against the MTU of the
	* netif used for a connection and limits the MSS if it would be too big otherwise.
	*/

config LWIP_TCP_LISTEN_BACKLOG
bool "TCP_LISTEN_BACKLOG"
default n 
help
	/**
	* TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb.
	*/

config LWIP_TCP_TIMESTAMPS
bool "LWIP_TCP_TIMESTAMPS"
default n 
help
	/**
	* LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option.
	*/

config LWIP_EVENT_API
bool "LWIP_EVENT_API"
default n 
help
	/**
	* LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
	*     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
	*         events (accept, sent, etc) that happen in the system.
	*     LWIP_CALLBACK_API==1: The PCB callback function is called directly
	*         for the event.
	*/

config LWIP_CALLBACK_API
bool "LWIP_CALLBACK_API"
default y 
help
	/**
	* LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
	*     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
	*         events (accept, sent, etc) that happen in the system.
	*     LWIP_CALLBACK_API==1: The PCB callback function is called directly
	*         for the event.
	*/

config LWIP_EVENT_API
bool "LWIP_EVENT_API"
default y 
help
	/**
	* LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
	*     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
	*         events (accept, sent, etc) that happen in the system.
	*     LWIP_CALLBACK_API==1: The PCB callback function is called directly
	*         for the event.
	*/

config LWIP_CALLBACK_API
bool "LWIP_CALLBACK_API"
default n 
help
	/**
	* LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
	*     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
	*         events (accept, sent, etc) that happen in the system.
	*     LWIP_CALLBACK_API==1: The PCB callback function is called directly
	*         for the event.
	*/


 endmenu 


menu "Pbuf options"


 endmenu 


menu "Network Interfaces options"

config LWIP_NETIF_HOSTNAME
bool "LWIP_NETIF_HOSTNAME"
default n 
help
	/**
	* LWIP_NETIF_HOSTNAME==1: use DHCP_OPTION_HOSTNAME with netif's hostname
	* field.
	*/

config LWIP_NETIF_API
bool "LWIP_NETIF_API"
default n 
help
	/**
	* LWIP_NETIF_API==1: Support netif api (in netifapi.c)
	*/

config LWIP_NETIF_STATUS_CALLBACK
bool "LWIP_NETIF_STATUS_CALLBACK"
default n 
help
	/**
	* LWIP_NETIF_STATUS_CALLBACK==1: Support a callback function whenever an interface
	* changes its up/down status (i.e., due to DHCP IP acquistion)
	*/

config LWIP_NETIF_LINK_CALLBACK
bool "LWIP_NETIF_LINK_CALLBACK"
default n 
help
	/**
	* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
	* whenever the link changes (i.e., link down)
	*/

config LWIP_NETIF_HWADDRHINT
bool "LWIP_NETIF_HWADDRHINT"
default n 
help
	/**
	* LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g. table
	* indices) in struct netif. TCP and UDP can make use of this to prevent
	* scanning the ARP table for every sent packet. While this is faster for big
	* ARP tables or many concurrent connections, it might be counterproductive
	* if you have a tiny ARP table or if there never are concurrent connections.
	*/

config LWIP_NETIF_LOOPBACK
bool "LWIP_NETIF_LOOPBACK"
default n 
help
	/**
	* LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP
	* address equal to the netif IP address, looping them back up the stack.
	*/

config LWIP_LOOPBACK_MAX_PBUFS
bool "LWIP_LOOPBACK_MAX_PBUFS"
default n 
help
	/**
	* LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback
	* sending for each netif (0 = disabled)
	*/

config LWIP_NETIF_TX_SINGLE_PBUF
bool "LWIP_NETIF_TX_SINGLE_PBUF"
default n 
help
	/**
	* LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data
	* to be sent into one single pbuf. This is for compatibility with DMA-enabled
	* MACs that do not support scatter-gather.
	* Beware that this might involve CPU-memcpy before transmitting that would not
	* be needed without this flag! Use this only if you need to!
	*
	* @todo: TCP and IP-frag do not work with this, yet:
	*/


 endmenu 


menu "LOOPIF options"

config LWIP_HAVE_LOOPIF
bool "LWIP_HAVE_LOOPIF"
default n 
help
	/**
	* LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1) and loopif.c
	*/


 endmenu 


menu "SLIPIF options"

config LWIP_HAVE_SLIPIF
bool "LWIP_HAVE_SLIPIF"
default n 
help
	/**
	* LWIP_HAVE_SLIPIF==1: Support slip interface and slipif.c
	*/


 endmenu 


menu "Thread options"

config LWIP_TCPIP_THREAD_NAME
string "TCPIP_THREAD_NAME"
default "tcpip_thread"
help
	/**
	* TCPIP_THREAD_NAME: The name assigned to the main tcpip thread.
	*/

config LWIP_TCPIP_THREAD_STACKSIZE
bool "TCPIP_THREAD_STACKSIZE"
default n 
help
	/**
	* TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
	* The stack size value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_TCPIP_THREAD_PRIO
bool "TCPIP_THREAD_PRIO"
default y 
help
	/**
	* TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.
	* The priority value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_TCPIP_MBOX_SIZE
bool "TCPIP_MBOX_SIZE"
default n 
help
	/**
	* TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
	* The queue size value itself is platform-dependent, but is passed to
	* sys_mbox_new() when tcpip_init is called.
	*/

config LWIP_SLIPIF_THREAD_NAME
string "SLIPIF_THREAD_NAME"
default "slipif_loop"
help
	/**
	* SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread.
	*/

config LWIP_SLIPIF_THREAD_STACKSIZE
bool "SLIPIF_THREAD_STACKSIZE"
default n 
help
	/**
	* SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
	* The stack size value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_SLIPIF_THREAD_PRIO
bool "SLIPIF_THREAD_PRIO"
default y 
help
	/**
	* SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.
	* The priority value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_PPP_THREAD_NAME
string "PPP_THREAD_NAME"
default "pppInputThread"
help
	/**
	* PPP_THREAD_NAME: The name assigned to the pppInputThread.
	*/

config LWIP_PPP_THREAD_STACKSIZE
bool "PPP_THREAD_STACKSIZE"
default n 
help
	/**
	* PPP_THREAD_STACKSIZE: The stack size used by the pppInputThread.
	* The stack size value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_PPP_THREAD_PRIO
bool "PPP_THREAD_PRIO"
default y 
help
	/**
	* PPP_THREAD_PRIO: The priority assigned to the pppInputThread.
	* The priority value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_DEFAULT_THREAD_NAME
string "DEFAULT_THREAD_NAME"
default "lwIP"
help
	/**
	* DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread.
	*/

config LWIP_DEFAULT_THREAD_STACKSIZE
bool "DEFAULT_THREAD_STACKSIZE"
default n 
help
	/**
	* DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
	* The stack size value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_DEFAULT_THREAD_PRIO
bool "DEFAULT_THREAD_PRIO"
default y 
help
	/**
	* DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.
	* The priority value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_DEFAULT_RAW_RECVMBOX_SIZE
bool "DEFAULT_RAW_RECVMBOX_SIZE"
default n 
help
	/**
	* DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
	* NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
	* to sys_mbox_new() when the recvmbox is created.
	*/

config LWIP_DEFAULT_UDP_RECVMBOX_SIZE
bool "DEFAULT_UDP_RECVMBOX_SIZE"
default n 
help
	/**
	* DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
	* NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
	* to sys_mbox_new() when the recvmbox is created.
	*/

config LWIP_DEFAULT_TCP_RECVMBOX_SIZE
bool "DEFAULT_TCP_RECVMBOX_SIZE"
default n 
help
	/**
	* DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
	* NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
	* to sys_mbox_new() when the recvmbox is created.
	*/

config LWIP_DEFAULT_ACCEPTMBOX_SIZE
bool "DEFAULT_ACCEPTMBOX_SIZE"
default n 
help
	/**
	* DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
	* The queue size value itself is platform-dependent, but is passed to
	* sys_mbox_new() when the acceptmbox is created.
	*/


 endmenu 


menu "Sequential layer options"

config LWIP_TCPIP_CORE_LOCKING
bool "LWIP_TCPIP_CORE_LOCKING"
default n 
help
	/**
	* LWIP_TCPIP_CORE_LOCKING: (EXPERIMENTAL!)
	* Don't use it if you're not an active lwIP project member
	*/

config LWIP_TCPIP_CORE_LOCKING_INPUT
bool "LWIP_TCPIP_CORE_LOCKING_INPUT"
default n 
help
	/**
	* LWIP_TCPIP_CORE_LOCKING_INPUT: (EXPERIMENTAL!)
	* Don't use it if you're not an active lwIP project member
	*/

config LWIP_NETCONN
bool "LWIP_NETCONN"
default y 
help
	/**
	* LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
	*/

config LWIP_TCPIP_TIMEOUT
bool "LWIP_TCPIP_TIMEOUT"
default y 
help
	/** LWIP_TCPIP_TIMEOUT==1: Enable tcpip_timeout/tcpip_untimeout tod create
	* timers running in tcpip_thread from another thread.
	*/


 endmenu 


menu "Socket options"

config LWIP_SOCKET
bool "LWIP_SOCKET"
default y 
help
	/**
	* LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
	*/

config LWIP_COMPAT_SOCKETS
bool "LWIP_COMPAT_SOCKETS"
default y 
help
	/**
	* LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
	* (only used if you use sockets.c)
	*/

config LWIP_POSIX_SOCKETS_IO_NAMES
bool "LWIP_POSIX_SOCKETS_IO_NAMES"
default y 
help
	/**
	* LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names.
	* Disable this option if you use a POSIX operating system that uses the same
	* names (read, write & close). (only used if you use sockets.c)
	*/

config LWIP_TCP_KEEPALIVE
bool "LWIP_TCP_KEEPALIVE"
default n 
help
	/**
	* LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT
	* options processing. Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set
	* in seconds. (does not require sockets.c, and will affect tcp.c)
	*/

config LWIP_SO_RCVTIMEO
bool "LWIP_SO_RCVTIMEO"
default n 
help
	/**
	* LWIP_SO_RCVTIMEO==1: Enable SO_RCVTIMEO processing.
	*/

config LWIP_SO_RCVBUF
bool "LWIP_SO_RCVBUF"
default n 
help
	/**
	* LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing.
	*/

config LWIP_SO_REUSE
bool "SO_REUSE"
default n 
help
	/**
	* SO_REUSE==1: Enable SO_REUSEADDR option.
	*/

config LWIP_SO_REUSE_RXTOALL
bool "SO_REUSE_RXTOALL"
default n 
help
	/**
	* SO_REUSE_RXTOALL==1: Pass a copy of incoming broadcast/multicast packets
	* to all local matches if SO_REUSEADDR is turned on.
	* WARNING: Adds a memcpy for every packet if passing to more than one pcb!
	*/


 endmenu 


menu "Statistics options"

config LWIP_STATS
bool "LWIP_STATS"
default y 
help
	/**
	* LWIP_STATS==1: Enable statistics collection in lwip_stats.
	*/

config LWIP_STATS_DISPLAY
bool "LWIP_STATS_DISPLAY"
default n 
help
	/**
	* LWIP_STATS_DISPLAY==1: Compile in the statistics output functions.
	*/

config LWIP_LINK_STATS
bool "LINK_STATS"
default y 
help
	/**
	* LINK_STATS==1: Enable link stats.
	*/

config LWIP_IP_STATS
bool "IP_STATS"
default y 
help
	/**
	* IP_STATS==1: Enable IP stats.
	*/

config LWIP_ICMP_STATS
bool "ICMP_STATS"
default y 
help
	/**
	* ICMP_STATS==1: Enable ICMP stats.
	*/

config LWIP_LINK_STATS
bool "LINK_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_IP_STATS
bool "IP_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_IPFRAG_STATS
bool "IPFRAG_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_ICMP_STATS
bool "ICMP_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_IGMP_STATS
bool "IGMP_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_UDP_STATS
bool "UDP_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_TCP_STATS
bool "TCP_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_MEM_STATS
bool "MEM_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_MEMP_STATS
bool "MEMP_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_SYS_STATS
bool "SYS_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_STATS_DISPLAY
bool "LWIP_STATS_DISPLAY"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/


 endmenu 


menu "PPP options"

config LWIP_PPP_SUPPORT
bool "PPP_SUPPORT"
default n 
help
	/**
	* PPP_SUPPORT==1: Enable PPP.
	*/

config LWIP_PPPOE_SUPPORT
bool "PPPOE_SUPPORT"
default n 
help
	/**
	* PPPOE_SUPPORT==1: Enable PPP Over Ethernet
	*/

config LWIP_NUM_PPP
int "NUM_PPP"
default 1
help
	/**
	* NUM_PPP: Max PPP sessions.
	*/

config LWIP_PAP_SUPPORT
bool "PAP_SUPPORT"
default n 
help
	/**
	* PAP_SUPPORT==1: Support PAP.
	*/

config LWIP_CHAP_SUPPORT
bool "CHAP_SUPPORT"
default n 
help
	/**
	* CHAP_SUPPORT==1: Support CHAP.
	*/

config LWIP_MSCHAP_SUPPORT
bool "MSCHAP_SUPPORT"
default n 
help
	/**
	* MSCHAP_SUPPORT==1: Support MSCHAP. CURRENTLY NOT SUPPORTED! DO NOT SET!
	*/

config LWIP_CBCP_SUPPORT
bool "CBCP_SUPPORT"
default n 
help
	/**
	* CBCP_SUPPORT==1: Support CBCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
	*/

config LWIP_CCP_SUPPORT
bool "CCP_SUPPORT"
default n 
help
	/**
	* CCP_SUPPORT==1: Support CCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
	*/

config LWIP_VJ_SUPPORT
bool "VJ_SUPPORT"
default n 
help
	/**
	* VJ_SUPPORT==1: Support VJ header compression.
	*/

config LWIP_MD5_SUPPORT
bool "MD5_SUPPORT"
default n 
help
	/**
	* MD5_SUPPORT==1: Support MD5 (see also CHAP).
	*/

config LWIP_LCP_ECHOINTERVAL
bool "LCP_ECHOINTERVAL"
default n 
help
	/* Interval in seconds between keepalive echo requests, 0 to disable. */


 endmenu 


menu "Checksum options"

config LWIP_CHECKSUM_GEN_IP
bool "CHECKSUM_GEN_IP"
default y 
help
	/**
	* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.
	*/

config LWIP_CHECKSUM_GEN_UDP
bool "CHECKSUM_GEN_UDP"
default y 
help
	/**
	* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.
	*/

config LWIP_CHECKSUM_GEN_TCP
bool "CHECKSUM_GEN_TCP"
default y 
help
	/**
	* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.
	*/

config LWIP_CHECKSUM_CHECK_IP
bool "CHECKSUM_CHECK_IP"
default y 
help
	/**
	* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.
	*/

config LWIP_CHECKSUM_CHECK_UDP
bool "CHECKSUM_CHECK_UDP"
default y 
help
	/**
	* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.
	*/

config LWIP_CHECKSUM_CHECK_TCP
bool "CHECKSUM_CHECK_TCP"
default y 
help
	/**
	* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.
	*/

config LWIP_CHECKSUM_ON_COPY
bool "LWIP_CHECKSUM_ON_COPY"
default n 
help
	/**
	* LWIP_CHECKSUM_ON_COPY==1: Calculate checksum when copying data from
	* application buffers to pbufs.
	*/


 endmenu 


menu "Debugging options"

config LWIP_ETHARP_DEBUG
bool "Enable debugging in etharp.c."
default n

config LWIP_NETIF_DEBUG
bool "Enable debugging in netif.c."
default n

config LWIP_PBUF_DEBUG
bool "Enable debugging in pbuf.c."
default n

config LWIP_API_LIB_DEBUG
bool "Enable debugging in api_lib.c."
default n

config LWIP_API_MSG_DEBUG
bool "Enable debugging in api_msg.c."
default n

config LWIP_SOCKETS_DEBUG
bool "Enable debugging in sockets.c."
default n

config LWIP_ICMP_DEBUG
bool "Enable debugging in icmp.c."
default n

config LWIP_IGMP_DEBUG
bool "Enable debugging in igmp.c."
default n

config LWIP_INET_DEBUG
bool "Enable debugging in inet.c."
default n

config LWIP_IP_DEBUG
bool "Enable debugging for IP."
default n

config LWIP_IP_REASS_DEBUG
bool "Enable debugging in ip_frag.c for both frag & reass."
default n

config LWIP_RAW_DEBUG
bool "Enable debugging in raw.c."
default n

config LWIP_MEM_DEBUG
bool "Enable debugging in mem.c."
default n

config LWIP_MEMP_DEBUG
bool "Enable debugging in memp.c."
default n

config LWIP_SYS_DEBUG
bool "Enable debugging in sys.c."
default n

config LWIP_TIMERS_DEBUG
bool "Enable debugging in timers.c."
default n

config LWIP_TCP_DEBUG
bool "Enable debugging for TCP."
default n

config LWIP_TCP_INPUT_DEBUG
bool "Enable debugging in tcp_in.c for incoming debug."
default n

config LWIP_TCP_FR_DEBUG
bool "Enable debugging in tcp_in.c for fast retransmit."
default n

config LWIP_TCP_RTO_DEBUG
bool "Enable debugging in TCP for retransmit  timeout."
default n

config LWIP_TCP_CWND_DEBUG
bool "Enable debugging for TCP congestion window."
default n

config LWIP_TCP_WND_DEBUG
bool "Enable debugging in tcp_in.c for window updating."
default n

config LWIP_TCP_OUTPUT_DEBUG
bool "Enable debugging in tcp_out.c output functions."
default n

config LWIP_TCP_RST_DEBUG
bool "Enable debugging for TCP with the RST message."
default n

config LWIP_TCP_QLEN_DEBUG
bool "Enable debugging for TCP queue lengths."
default n

config LWIP_UDP_DEBUG
bool "Enable debugging in UDP."
default n

config LWIP_TCPIP_DEBUG
bool "Enable debugging in tcpip.c."
default n

config LWIP_PPP_DEBUG
bool "Enable debugging for PPP."
default n

config LWIP_SLIP_DEBUG
bool "Enable debugging in slipif.c."
default n

config LWIP_DHCP_DEBUG
bool "Enable debugging in dhcp.c."
default n

config LWIP_AUTOIP_DEBUG
bool "Enable debugging in autoip.c."
default n

config LWIP_SNMP_MSG_DEBUG
bool "Enable debugging for SNMP messages."
default n

config LWIP_SNMP_MIB_DEBUG
bool "Enable debugging for SNMP MIBs."
default n

config LWIP_DNS_DEBUG
bool "Enable debugging for DNS."
default n


 endmenu 


